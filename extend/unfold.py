##########################################################################
# this script was generated by openmm-builder. to customize it further,
# you can save the file to disk and edit it with your favorite editor.
##########################################################################

#from __future__ import print_function
from simtk.openmm.app import *
from simtk.openmm import *
from simtk.unit import *
from sys import stdout

import xml.etree.ElementTree as etree
from openmmtools.pullingforcewrapper import PullingForceWrapper
from openmmtools.webreporter import WebReporter
import threading

import numpy as np
import IPython as ip

##############################################################################

timestep = 2.0*femtoseconds
elongation_factor = 8.0
total_time = 10*nanoseconds
n_steps = int(total_time / timestep)
report_interval = int(10*picoseconds / timestep)

temperature = 500*kelvin

##############################################################################

pdb = PDBFile('../native.pdb')

pdb.topology.loadBondDefinitions('../residues-nle.xml')
pdb.topology.createStandardBonds()

forcefield = ForceField('amber99sbildn.xml', '../amber99sbildn-nle.xml',
                        '../amber99-nle_obc.xml')

system = forcefield.createSystem(pdb.topology, nonbondedMethod=CutoffNonPeriodic, 
    constraints=None, rigidWater=True, nonbondedCutoff=1.0*nanometers)

integrator = LangevinIntegrator(temperature, 91.0/picoseconds, timestep)
integrator.setConstraintTolerance(0.0001)

pullingforce = PullingForceWrapper(pdb=pdb)
pullingforce.add_to_system(system)

simulation = Simulation(pdb.topology, system, integrator)
simulation.context.setPositions(pdb.positions)


print 'Minimizing...'
simulation.minimizeEnergy()

simulation.context.setVelocitiesToTemperature(temperature)

# setup the reporters
simulation.reporters.append(DCDReporter('unfolding.dcd', report_interval))
simulation.reporters.append(StateDataReporter(stdout, report_interval, temperature=True, step=True, time=True,
                                              kineticEnergy=True, potentialEnergy=True))    

simulation.step(n_steps)
